<script>

  //use multiple conditional (terinary) operator
  function checkSign(num) {
    return num > 0 ? "positive" : num < 0 ? "negative" : "zero"
  }
  console.log(checkSign(-10));



  //difference between var and let keywords
  //let doesnot let you declare a variable twice
  let catName = "Quincy";
  var quote;
  catName = "beau";

  function catTalk() {
    catName = "oliver";
    return quote = catName + " says meow";
  }
  console.log(catTalk());



  //compare scope of var and let keywords
  function checkScope() {
    let i = "function scope";
    if (true) {
      let i = "block scope";
      console.log("block scope of i is " + i);
    }
    console.log("function scope of i is " + i);
    return i;
  }
  console.log(checkScope());



  //declare a read only variable with const keyword
  //const have all the features of let , but its readonly. you cannot reassign a const
  function checkConst(str) {
    const SENTENCE = "my name is" + str; //make const variables in full capital letters
    //SENTENCE = "my friends name is" + str; // this will make an error as we are reassigning const
    console.log(SENTENCE)
  }
  checkConst("anu");



  //mutate an array declared with const
  const s = [1, 2, 3];
  function editInPlace() {
    // s = [5,6,7];  //cannot use this
    //but we can use bracket notation
    s[0] = 10;
    s[1] = 11;
    s[2] = 12;
    console.log(s)
  }
  editInPlace();



  //prevent object mutation
  function freezeObject() {
    const MATH_CONSTANT = {
      PI: 3.14
    };
    Object.freeze(MATH_CONSTANT); //The Object.freeze() method freezes an object
    //A frozen object can no longer be changed; 
    //freezing an object prevents new properties from being added to it, existing properties from 
    //being removed, prevents changing the enumerability, configurability, or writability of existing properties, and 
    //prevents the values of existing properties from being changed.
    try {
      MATH_CONSTANT.PI = 99;
    } catch (ex) {
      console.log(ex);
    }
    return MATH_CONSTANT.PI;
  }
  const PI = freezeObject();
  console.log(PI)



  //use arrow functions to write concise anonmous functions
  //    var magic = function(){
  //       return new Date();
  //    };
  //the above anonymous function can be converted intoarrow functions 
  var magic = () => {
    return new Date();
  };
  //if the function returns only one value it can be  also written as 
  // var magic = () => new Date();



  //write arrow function with parameter
  //  var myDetails = function(array1,array2){
  //   return array1.concat(array2);
  //  }
  //the above anonymous function is converted in to arrow function(with arguments)
  var myDetails = (array1, array2) => array1.concat(array2);
  console.log(myDetails([1, 2], [3, 4]))



//write higher order arrow function
const realNumberArray = [4,5.7,8,7.9,1];
const squareList = (arr) => {
const squaredIntegers = arr.filter(num => Number.isInteger(num) && num>0).map(x => x * x);
return squaredIntegers;
};
const squaredIntegers = squareList(realNumberArray);
console.log(squaredIntegers);


//write higher order arrow functions
const increment = (function (){
return function increment(number,value = 1){
  return number + value;
};
})();
console.log(increment(5,2));
console.log(increment(5));



//use the rest operator with function parameters
const sum = (function(){
//return function sum(x, y, z){ 
  return function sum(...args){ //instead of using x,y,z as arguments use ...args (ie rest operators) can add any number of arguments
 // const args = [x,y,z];  
  return args.reduce((a,b) => a+b,0);
};
})();
console.log(sum(1, 2, 4, 10));



//use spread operator to evaluate arrays in place
const arrMonth = ['jan','feb','mar','apr','may'];
let arr2;
(function(){
  // arr2 = arrMonth;
  arr2 = [...arrMonth]; //using spread operator
  arrMonth[0]='potato';
})();
console.log(arr2);


//use destructuring Assignment to assign variables from object
var voxel = {x:3.7, y:8.1, z:2.1};

//assigning variables for each element in an object
// var x = voxel.x;
// var y = voxel.y;
// var z = voxel.z;


const {x:a, y:b, z:c} = voxel; //this is the destructuring syntax. quicker way of assigning elements of objects into variables
//get value of x from object voxel and assign it into variable a
//get value of y from object voxel and assign it into variable b
//get value of z from object voxel and assign it into variable c

const AVG_TEMPERATURES = {
today: 77.5,
tomorrow: 79
};
function getTempOfTomorow() {

}

//destructuring assignment with nested objects
const LOCAL_FORECAST = {
  today: { min: 72, max:83 },
  tomorrow: {min: 73.3, max:84.6}
};
function getMaxOfTmrw(forecast){
  const { tomorrow: { max: maxOfTomorrow }} = forecast;
  return maxOfTomorrow;
}
console.log(getMaxOfTmrw(LOCAL_FORECAST));

</script>